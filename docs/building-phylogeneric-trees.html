<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Lecture 16 Building phylogeneric trees | Fundamentals of Biological Data Analysis</title>
<meta name="author" content="Dmitry Kondrashov and Stefano Allesina">
<meta name="description" content="Let’s import some libraries: library(ape) # most important library for phylogeny library(phangorn) # tree reconstruction  16.1 Introduction  Darwin’s tree Since Darwin’s “I think…” biologists have...">
<meta name="generator" content="bookdown 0.29 with bs4_book()">
<meta property="og:title" content="Lecture 16 Building phylogeneric trees | Fundamentals of Biological Data Analysis">
<meta property="og:type" content="book">
<meta property="og:description" content="Let’s import some libraries: library(ape) # most important library for phylogeny library(phangorn) # tree reconstruction  16.1 Introduction  Darwin’s tree Since Darwin’s “I think…” biologists have...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lecture 16 Building phylogeneric trees | Fundamentals of Biological Data Analysis">
<meta name="twitter:description" content="Let’s import some libraries: library(ape) # most important library for phylogeny library(phangorn) # tree reconstruction  16.1 Introduction  Darwin’s tree Since Darwin’s “I think…” biologists have...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.4.0/transition.js"></script><script src="libs/bs3compat-0.4.0/tabs.js"></script><script src="libs/bs3compat-0.4.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Fundamentals of Biological Data Analysis</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Organization of the class</a></li>
<li><a class="" href="refresher.html"><span class="header-section-number">1</span> Refresher</a></li>
<li><a class="" href="visualizing-data-using-ggplot2.html"><span class="header-section-number">2</span> Visualizing data using ggplot2</a></li>
<li><a class="" href="fundamentals-of-probability.html"><span class="header-section-number">3</span> Fundamentals of probability</a></li>
<li><a class="" href="data-wrangling.html"><span class="header-section-number">4</span> Data wrangling</a></li>
<li><a class="" href="distributions-and-their-properties.html"><span class="header-section-number">5</span> Distributions and their properties</a></li>
<li><a class="" href="hypothesis-testing.html"><span class="header-section-number">6</span> Hypothesis testing</a></li>
<li><a class="" href="likelihood-and-bayes.html"><span class="header-section-number">7</span> Likelihood and Bayes</a></li>
<li><a class="" href="review-of-linear-algebra.html"><span class="header-section-number">8</span> Review of linear algebra</a></li>
<li><a class="" href="linear-models.html"><span class="header-section-number">9</span> Linear models</a></li>
<li><a class="" href="anova.html"><span class="header-section-number">10</span> ANOVA</a></li>
<li><a class="" href="model-selection.html"><span class="header-section-number">11</span> Model Selection</a></li>
<li><a class="" href="principal-component-analysis.html"><span class="header-section-number">12</span> Principal Component Analysis</a></li>
<li><a class="" href="clustering.html"><span class="header-section-number">13</span> Clustering</a></li>
<li><a class="" href="generalized-linear-models.html"><span class="header-section-number">14</span> Generalized linear models</a></li>
<li><a class="" href="machine-learning-methods-for-classification.html"><span class="header-section-number">15</span> Machine learning methods for classification</a></li>
<li><a class="active" href="building-phylogeneric-trees.html"><span class="header-section-number">16</span> Building phylogeneric trees</a></li>
<li><a class="" href="time-series-modeling-and-forecasting.html"><span class="header-section-number">17</span> Time series: modeling and forecasting</a></li>
<li><a class="" href="monte-carlo-methods.html"><span class="header-section-number">18</span> Monte Carlo methods</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="building-phylogeneric-trees" class="section level1" number="16">
<h1>
<span class="header-section-number">Lecture 16</span> Building phylogeneric trees<a class="anchor" aria-label="anchor" href="#building-phylogeneric-trees"><i class="fas fa-link"></i></a>
</h1>
<p>Let’s import some libraries:</p>
<div class="sourceCode" id="cb886"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://ape-package.ird.fr/">ape</a></span><span class="op">)</span> <span class="co"># most important library for phylogeny</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/KlausVigo/phangorn">phangorn</a></span><span class="op">)</span> <span class="co"># tree reconstruction</span></span></code></pre></div>
<div id="introduction-2" class="section level2" number="16.1">
<h2>
<span class="header-section-number">16.1</span> Introduction<a class="anchor" aria-label="anchor" href="#introduction-2"><i class="fas fa-link"></i></a>
</h2>
<div class="figure">
<img src="images/darwin.jpg" alt=""><p class="caption">Darwin’s tree</p>
</div>
<p>Since Darwin’s “I think…” biologists have been constructing trees connecting species to their common ancestors. The goal of this brief tutorial is to introduce some of the basic terminology, and illustrate the most common approaches to building trees.</p>
<p>This tutorial is based on the freely available book <a href="https://jarhodesuaf.github.io/PhyloBook.pdf">The Mathematics of Phylogenetics</a>, by Allman and Rhodes.</p>
</div>
<div id="input-1" class="section level2" number="16.2">
<h2>
<span class="header-section-number">16.2</span> Input<a class="anchor" aria-label="anchor" href="#input-1"><i class="fas fa-link"></i></a>
</h2>
<p>The input is assumed to be a series of <strong>sequences</strong>, one for each <strong>taxon</strong>. For simplicity, we deal with DNA sequences, and assume that the taxa are different species. However, the methods introduced here can be extended to other types of sequences (e.g., amino acids, RNA, morphological features) and taxa (e.g., individuals of the same species, or even cells from the same individual). We assume the DNA sequences to be <strong>orthologous</strong> (i.e., to have descended from a common ancestral sequence) and to have been <strong>aligned</strong> (i.e., having many of the bases matching across the sequences for all the taxa).</p>
<p>DNA is composed of four nucleotides or <strong>bases</strong>: adenine (<code>A</code>), guanine (<code>G</code>), cytosine (<code>C</code>), and thymine (<code>T</code>). <code>A</code> and <code>G</code> are both purines, <code>C</code> and <code>T</code> are pyrimidines. When DNA is copied, small errors (<strong>mutations</strong>) can be introduced: we speak of <strong>substitutions</strong> when a base is changed, <strong>deletions</strong> when one or more consecutive bases are not copied, and <strong>insertions</strong> when new bases are introduced in the sequence. For this tutorial, we will concentrate on substitutions, which are believed to be the most common type of mutations. We distinguish between <strong>transition</strong> (from a purine to the other purine, or from pyrimidine to pyrimidine) and <strong>transversion</strong> (from one type to the other). Many models assume that transitions are more frequent than transversions (due to smaller changes in chemical stability of DNA).</p>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th align="right">Taxon</th>
<th align="left">Sequence</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">Tax 1</td>
<td align="left">ATT<strong>G</strong>CAA<strong>TG</strong>GCA</td>
</tr>
<tr class="even">
<td align="right">Tax 2</td>
<td align="left">ATT<strong>G</strong>CAA<strong>TA</strong>GCA</td>
</tr>
<tr class="odd">
<td align="right">Tax 3</td>
<td align="left">ATT<strong>A</strong>CAA<strong>CG</strong>GCA</td>
</tr>
<tr class="even">
<td align="right">Tax 4</td>
<td align="left">ATT<strong>A</strong>CAA<strong>CA</strong>GCA</td>
</tr>
</tbody>
</table></div>
</div>
<div id="representing-trees" class="section level2" number="16.3">
<h2>
<span class="header-section-number">16.3</span> Representing trees<a class="anchor" aria-label="anchor" href="#representing-trees"><i class="fas fa-link"></i></a>
</h2>
<p>A graph is a collection of vertices (<span class="math inline">\(V\)</span>) and edges (<span class="math inline">\(E\)</span>). We consider simple, undirected graph for most of the tutorial; simple means that self loops are not allowed and that each two nodes can be connected by one edge at most; undirected that we do not distinguish between <span class="math inline">\(a \to b\)</span> and <span class="math inline">\(b \to a\)</span>. A graph is <strong>connected</strong> if there is a way to go from any node to any other following its edges. A <strong>cycle</strong> is a closed path connecting a node to itself. A <strong>tree</strong> is a connected graph that contains no cycles.</p>
<p>We distinguish between <strong>rooted</strong> and <strong>unrooted</strong> trees: the root is a particular vertex from which all other taxa descend (the MRCA, most recent common ancestor of all taxa). Note that by placing the root in different places, we can obtain dramatically different-looking trees:</p>
<center>
<img src="https://slideplayer.com/slide/8111866/25/images/9/Altering+the+position+of+root%2C+changes+the+meaning+of+Phylogenetic+tree.jpg">
</center>
<p>Typically, we can only observe the <strong>tips</strong> or <strong>leaves</strong> of the tree (the extant species); their common ancestors are the <strong>internal nodes</strong> of the tree, which have to be inferred.</p>
<p>An unrooted tree with <span class="math inline">\(n &gt; 1\)</span> leaves contains exactly <span class="math inline">\(2n -2\)</span> nodes, and <span class="math inline">\(2n -3\)</span> edges. A rooted tree has one extra node (<span class="math inline">\(2n -1\)</span>) and one extra edge (<span class="math inline">\(2n - 2\)</span>). There are very many trees one can form with <span class="math inline">\(n\)</span> leaves: we can count <span class="math inline">\((2n -3)!!\)</span> rooted trees (where the double factorial becomes <span class="math inline">\(1 \cdot 3 \cdot 5 \cdots (2n -3)\)</span>).</p>
<p>We can add a “length” to each edge, measuring how much change has accumulated between the two vertices. In case of “molecular clock” trees, we assume lengths to be measuring time, and all leaves have the same distance (computed summing the lengths along the branches) from the root. Trees in which all leaves have the same distance from the root are called <strong>ultrametric</strong>.</p>
<p>Mathematically, if we do not make an assumption of a “molecular clock” (i.e., that mutations are neutral and occur at a predictable rate), we cannot identify the root of a tree without using extra information. Typically, what is done is to also align sequence(s) stemming from an <strong>out-group</strong>, i.e., a taxon that is believed to be distantly related to the taxa we want to connect in our tree. Then, the root will connect the out-group taxon with the rest of the tree.</p>
<p>Many of the methods for tree reconstruction are based on unrooted, unweighted trees, and a root and lengths can be determined once one has chosen a topology for the tree.</p>
<p>A simple way to represent a tree is provided by the <strong>Newick notation</strong>: the string <code>(((a, b), c), (d, e))</code> represents a tree in which two nodes enclosed by parentheses are connected to a common ancestor (internal node). Note that the notation cannot readily discriminate among identical trees (e.g., <code>((d, e), (c, (b, a)))</code>) so that spotting two identical trees is difficult to do by eye.</p>
</div>
<div id="building-trees-from-sequence-data" class="section level2" number="16.4">
<h2>
<span class="header-section-number">16.4</span> Building trees from sequence data<a class="anchor" aria-label="anchor" href="#building-trees-from-sequence-data"><i class="fas fa-link"></i></a>
</h2>
<p>Provided with a set of orthologous, aligned sequences, we want to build a tree explaining the observed mutations. All methods to build trees from sequences are based on Occam’s razor: given alternative histories for the evolution of the sequences, take the “simplest” as the most probable.</p>
<div id="maximum-parsimony" class="section level3" number="16.4.1">
<h3>
<span class="header-section-number">16.4.1</span> Maximum Parsimony<a class="anchor" aria-label="anchor" href="#maximum-parsimony"><i class="fas fa-link"></i></a>
</h3>
<p>Going back to our example:</p>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th align="right">Taxon</th>
<th align="left">Sequence</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">Tax 1</td>
<td align="left">ATT<strong>G</strong>CAA<strong>TG</strong>GCA</td>
</tr>
<tr class="even">
<td align="right">Tax 2</td>
<td align="left">ATT<strong>G</strong>CAA<strong>TA</strong>GCA</td>
</tr>
<tr class="odd">
<td align="right">Tax 3</td>
<td align="left">ATT<strong>A</strong>CAA<strong>CG</strong>GCA</td>
</tr>
<tr class="even">
<td align="right">Tax 4</td>
<td align="left">ATT<strong>A</strong>CAA<strong>CA</strong>GCA</td>
</tr>
</tbody>
</table></div>
<p>we could think of the tree <span class="math inline">\(((1, 2), (3, 4))\)</span> that would be consistent with the changes in position 4 and 8; the changes in position 9, however, would require a further mutation for each branch. We can count the number of changes in the sequences required for each tree, and maximum parsimony can be summarized as “The best tree to infer from data is the one requiring the fewest changes”.</p>
<p>We can propose a tree, and for each edge connecting nodes <span class="math inline">\((u, v)\)</span>, we can count the number of changes required to go from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>. We can then sum all the changes (called the <strong>parsimony score</strong>) and choose the tree with the minimum score.</p>
<div class="figure">
<img src="images/parsimony.jpg" alt=""><p class="caption">Parsimony</p>
</div>
<p>Computing the minimum score for a given tree and sequences for the leaves is called the “small parsimony problem” while computing the minimum parsimony over all trees is the “large parsimony problem”. The small problem can be solved efficiently (e.g., using the <a href="https://media.uaf.edu/media/t/0_tjoxyuwx">Fitch-Hartigan</a> algorithm). The large problem is computationally very difficult.</p>
</div>
<div id="example-primates" class="section level3" number="16.4.2">
<h3>
<span class="header-section-number">16.4.2</span> Example: primates<a class="anchor" aria-label="anchor" href="#example-primates"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb887"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># read alignment primates</span></span>
<span><span class="va">fdir</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"extdata/trees"</span>, package <span class="op">=</span> <span class="st">"phangorn"</span><span class="op">)</span></span>
<span><span class="va">primates</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/read.phyDat.html">read.phyDat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/file.path.html">file.path</a></span><span class="op">(</span><span class="va">fdir</span>, <span class="st">"primates.dna"</span><span class="op">)</span>, format <span class="op">=</span> <span class="st">"interleaved"</span><span class="op">)</span></span>
<span><span class="va">primates</span><span class="op">$</span><span class="va">Human</span></span></code></pre></div>
<pre><code>##   [1] 1 2 2 2 2 1 2 4 2 1 2 2 2 1 4 1 2 1 1 1 2 1 1 2 1 2 2 1 2 4 2 4 2 2 2 2 4
##  [38] 1 1 4 4 1 2 1 1 4 4 4 1 1 2 2 4 2 2 2 1 2 2 4 4 2 1 3 1 1 2 4 3 1 1 2 3 2
##  [75] 2 1 1 4 2 4 2 1 4 1 1 2 2 1 1 2 1 2 1 2 2 2 2 1 4 2 1 1 1 3 2 1 2 2 2 2 4
## [112] 2 2 1 1 2 1 2 1 2 2 2 3 2 1 2 1 2 2 4 2 2 1 2 2 2 2 2 2 4 2 3 4 2 4 1 2 3
## [149] 2 4 4 1 2 2 1 2 3 4 2 4 2 2 2 4 2 2 2 4 2 4 2 1 2 1 2 2 4 4 1 2 4 2 1 2 2
## [186] 4 4 2 4 2 2 2 1 1 1 2 3 1 2 4 4 2 3 2 1 2 2 1 2 1 1 2 3 2 2 1 2</code></pre>
<p>Now let’s build a random tree and compute parsimony:</p>
<div class="sourceCode" id="cb889"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span><span class="co"># generate random tree</span></span>
<span><span class="va">my_tree</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/rtree.html">rtree</a></span><span class="op">(</span><span class="fl">14</span>, rooted <span class="op">=</span> <span class="cn">FALSE</span>, tip.label <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">primates</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">my_tree</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-372-1.png" width="672"></div>
<p>We can compute the parsimony score for the tree:</p>
<div class="sourceCode" id="cb890"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">parsimony</a></span><span class="op">(</span><span class="va">my_tree</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 944</code></pre>
<p>Meaning that to recover the observed sequences from the ancestral one, we need to assume 921 changes have occurred. Clearly, this doesn’t seem to be an especially promising tree (for example, Humans and Chimpanzees are quite far, while we know that they should be close). Let’s try with another random tree:</p>
<div class="sourceCode" id="cb892"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># try with another one</span></span>
<span><span class="va">my_tree2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/rtree.html">rtree</a></span><span class="op">(</span><span class="fl">14</span>, rooted <span class="op">=</span> <span class="cn">FALSE</span>, tip.label <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">primates</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">my_tree2</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-374-1.png" width="672"></div>
<div class="sourceCode" id="cb893"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">parsimony</a></span><span class="op">(</span><span class="va">my_tree2</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 931</code></pre>
<p>Which is even worse! We can try to “tweak” the structure of the tree to reduce the parsimony score by calling <code>optim.parsimony</code>. For example:</p>
<div class="sourceCode" id="cb895"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># try to find a good tree</span></span>
<span><span class="va">optim_tree</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">optim.parsimony</a></span><span class="op">(</span><span class="va">my_tree</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Final p-score 746 after  24 nni operations</code></pre>
<div class="sourceCode" id="cb897"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">optim_tree</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-375-1.png" width="672"></div>
<p>Trying with the other random tree:</p>
<div class="sourceCode" id="cb898"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">optim_tree2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">optim.parsimony</a></span><span class="op">(</span><span class="va">my_tree2</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Final p-score 746 after  21 nni operations</code></pre>
<div class="sourceCode" id="cb900"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">optim_tree2</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-376-1.png" width="672"></div>
<p>This shows that the starting tree matters. In fact, we do not find especially good solutions even after calling <code>optim.parsimony</code>. Now we are going to try again but with a starting tree based on distances (explained below).</p>
<div class="sourceCode" id="cb901"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># compute distances</span></span>
<span><span class="va">dm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/dist.hamming.html">dist.ml</a></span><span class="op">(</span><span class="va">primates</span><span class="op">)</span></span>
<span><span class="co"># build tree using distances</span></span>
<span><span class="va">treeNJ</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/NJ.html">NJ</a></span><span class="op">(</span><span class="va">dm</span><span class="op">)</span></span>
<span><span class="va">treeUPGMA</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/upgma.html">upgma</a></span><span class="op">(</span><span class="va">dm</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">parsimony</a></span><span class="op">(</span><span class="va">treeNJ</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 746</code></pre>
<div class="sourceCode" id="cb903"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">optim_tree3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">optim.parsimony</a></span><span class="op">(</span><span class="va">treeNJ</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Final p-score 746 after  0 nni operations</code></pre>
<div class="sourceCode" id="cb905"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">optim_tree3</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-377-1.png" width="672"></div>
<div class="sourceCode" id="cb906"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">parsimony</a></span><span class="op">(</span><span class="va">treeUPGMA</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 751</code></pre>
<div class="sourceCode" id="cb908"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">optim_tree4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/parsimony.html">optim.parsimony</a></span><span class="op">(</span><span class="va">treeUPGMA</span>, <span class="va">primates</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Final p-score 746 after  1 nni operations</code></pre>
<div class="sourceCode" id="cb910"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">optim_tree4</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-377-2.png" width="672"></div>
</div>
<div id="parsimonygate" class="section level3" number="16.4.3">
<h3>
<span class="header-section-number">16.4.3</span> <code>#ParsimonyGate</code><a class="anchor" aria-label="anchor" href="#parsimonygate"><i class="fas fa-link"></i></a>
</h3>
<p>Maximum parsimony is often used, but has several problems (in fact, no method is perfect, and each has strengths and limitations). For example, there typically exist several trees with the same score.</p>
<p>The journal <em>Cladistics</em> published an editorial in February 2016 stating that “Phylogenetic data sets submitted to this journal should be analysed using parsimony. If alternative methods give different results and the author prefers an unparsimonious topology, he or she is welcome to present that result, but should be prepared to defend it on <strong>philosophical</strong> grounds” (emphasis mine). The mention of philosophy to justify scientific results led to a twitter storm, ignited by Jonathan Eisen (for an entertaining account, see <a href="https://www.wired.com/2016/02/twitter-nerd-fight-reveals-a-long-bizarre-scientific-feud/">here</a>).</p>
</div>
</div>
<div id="distance-methods" class="section level2" number="16.5">
<h2>
<span class="header-section-number">16.5</span> Distance Methods<a class="anchor" aria-label="anchor" href="#distance-methods"><i class="fas fa-link"></i></a>
</h2>
<p>A second class of methods is based on measuring “dissimilarity” (or “distance”) between sequences. The idea is then to preferentially connect with a common ancestors species that are “close”. This is similar to what we’ve done with MDS, and the basic notion of distance is the same. We start by computing a matrix of dissimilarities (or distances), and then use an algorithm to build a tree.</p>
<p>A simple method to build a tree given the dissimilarity matrix is called <em>unweighted pair-group method with arithmetic means</em> (<strong>UPGMA</strong>). The idea is very simple: we start by joining the two leaves that have the smallest distance. We then remove the leaves and add a new node that is the average between the two leaves. We then repeat the same operation until we have built the tree.</p>
<div class="figure">
<img src="images/upgma.png" alt=""><p class="caption">UPGMA</p>
</div>
<p>Note that the UPGMA builds trees with branch lengths and assumes that the data are produced by a molecular clock. Because this condition is often violated, we need to choose another algorithm whenever we suspect the dissimilarities are not stemming from an ultrametric tree. In practice, the “Neighbor Joining” algorithm (<strong>NJ</strong>) is often used.</p>
<p>The algorithm is based on the so-called four-point condition: given four taxa <span class="math inline">\(a, b, c, d\)</span> (which might include repetitions), in a metric tree we have</p>
<p><span class="math display">\[
\delta(a, b) + \delta(c, d) \leq \max\{\delta(a, c) + \delta(b, d), \delta(a, d) + \delta(b, c)\}
\]</span>
This inequality is used to choose with two leaves to join, and the process is repeated as in UPGMA. Despite being more complex, NJ is often used in practice to produce a good starting tree. Note that NJ builds an unrooted tree.</p>
<div class="sourceCode" id="cb911"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">treeNJ</span>, type <span class="op">=</span> <span class="st">"unrooted"</span>, lab4ut <span class="op">=</span> <span class="st">"axial"</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-378-1.png" width="672"></div>
</div>
<div id="likelihood-based-methods" class="section level2" number="16.6">
<h2>
<span class="header-section-number">16.6</span> Likelihood based methods<a class="anchor" aria-label="anchor" href="#likelihood-based-methods"><i class="fas fa-link"></i></a>
</h2>
<p>The goal of likelihood-based methods is to compute a probability of having observed a given set of sequences given a tree. To do so, we often make a strong <strong>assumption of independence</strong>: each site behaves independently, and the bases are taken from the same distribution (i.i.d.).</p>
<p>Because of this assumption, we do not care of the exact sequence, only of the number of bases of each kind. For example, we can assume that the <strong>root distribution vector</strong> is</p>
<p><span class="math display">\[
p_\rho = (p_A, p_G, p_C, p_T)
\]</span></p>
<p>with elements summing to one.</p>
<p>Now we can model the probability that a base in the root will mutate to another base by substitution along an edge <span class="math inline">\(e\)</span>. We can use a <strong>transition matrix</strong> (or <strong>Markov matrix</strong>):</p>
<p><span class="math display">\[
M_e = \begin{pmatrix}
p_{AA} &amp; p_{AG} &amp; p_{AC} &amp; p_{AT}\\
p_{GA} &amp; p_{GG} &amp; p_{GC} &amp; p_{GT}\\
p_{CA} &amp; p_{CG} &amp; p_{CC} &amp; p_{CT}\\
p_{TA} &amp; p_{TG} &amp; p_{TC} &amp; p_{TT}
\end{pmatrix}
\]</span></p>
<p>with non-negative entries and rows summing to one. This matrix encodes the probability that a base in the ancestor was substituted in the descendant along edge <span class="math inline">\(e\)</span>. But how can we compute the matrix for a given edge?</p>
<p>Clearly, each edge could give rise to its own Markov matrix, making it difficult to infer a tree from sequences. Instead, we can link all the matrices along all edges by making them all a function of a matrix of rates and the length of the edge. The solution is to build a matrix of rates <span class="math inline">\(Q\)</span> (with rows summing to zero, and off-diagonal elements that are positive). The elements of the matrix <span class="math inline">\(Q\)</span> describe the instantaneous rate of substitution. We then want to model the time elapsed along one edge. We solve the differential equation:</p>
<p><span class="math display">\[
\frac{d p(t)}{dt} = p(t) Q
\]</span></p>
<p>Because it is a linear system of ODEs:</p>
<p><span class="math display">\[
p(t) = p(0) e^{Qt} = p(0) S e^{\Lambda t} S^{-1}
\]</span></p>
<p>where <span class="math inline">\(S\)</span> is the matrix of eigenvectors, and <span class="math inline">\(\Lambda\)</span> the diagonal matrix of eigenvalues of <span class="math inline">\(Q\)</span>.</p>
<p>When we have an edge <span class="math inline">\(e\)</span> with corresponding time <span class="math inline">\(t_e\)</span>, we choose <span class="math inline">\(M_e = M(t_e) = e^{Qt_e}\)</span> to be the matrix projecting the proportion of bases in the ancestor to the number of bases in the descendant. In practice, out of computational convenience, often we choose <span class="math inline">\(Q\)</span> with a very special structure.</p>
<div id="jukes-cantor-model" class="section level4" number="16.6.0.1">
<h4>
<span class="header-section-number">16.6.0.1</span> Jukes-Cantor Model<a class="anchor" aria-label="anchor" href="#jukes-cantor-model"><i class="fas fa-link"></i></a>
</h4>
<p>This is the simplest model for base substitution. It assumes that in the ancestral sequence, all bases occur with the same probability:</p>
<p><span class="math display">\[
p_\rho = (1/4, 1/4, 1/4, 1/4)
\]</span>
and that each base is substituted by any other with equal rates:</p>
<p><span class="math display">\[
Q = \begin{pmatrix}
-\alpha &amp; \alpha / 3 &amp; \alpha / 3 &amp; \alpha / 3 \\
\alpha / 3 &amp; -\alpha &amp;  \alpha / 3 &amp; \alpha / 3 \\
\alpha / 3 &amp; \alpha / 3 &amp;  -\alpha &amp;  \alpha / 3 \\
\alpha / 3 &amp; \alpha / 3 &amp;   \alpha / 3 &amp; -\alpha
\end{pmatrix}
\]</span>
As such, the total rate at which a specific base is substituted (by any of the other three) is <span class="math inline">\(\alpha\)</span>. With some calculation, we find that:</p>
<p><span class="math display">\[
S = \begin{pmatrix}
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; -1 &amp; 1 &amp; -1 \\
1 &amp; 1 &amp; -1 &amp; -1 \\
1 &amp; -1 &amp; -1 &amp; 1
\end{pmatrix}
\]</span>
and</p>
<p><span class="math display">\[
\Lambda = \begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; -\frac{4}{3} \alpha &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -\frac{4}{3} \alpha &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -\frac{4}{3} \alpha\\
\end{pmatrix}
\]</span></p>
<p>and as such:</p>
<p><span class="math display">\[
M(t) = e^{Qt} = S e^{\Lambda t} S^{-1} = \begin{pmatrix}
1- a(t) &amp; a(t) / 3 &amp; a(t) / 3 &amp; a(t) / 3 \\
a(t) / 3 &amp; 1 -a(t) &amp;  a(t) / 3 &amp; a(t) / 3 \\
a(t) / 3 &amp; a(t) / 3 &amp;  1 -a(t) &amp;  a(t) / 3 \\
a(t) / 3 &amp; a(t) / 3 &amp;   a(t) / 3 &amp; 1-a(t)
\end{pmatrix}
\]</span></p>
<p>where <span class="math inline">\(a(t) = \frac{3}{4}\left(1 - e^{-\frac{4}{3} \alpha t}\right)\)</span>. Clearly, the larger the <span class="math inline">\(t\)</span> or the <span class="math inline">\(\alpha\)</span>, the more substitutions we expect to occur. Note however that the model encodes a stable base distribution at all vertices of the tree: <span class="math inline">\(p_\rho M(t) = p_\rho\)</span>.</p>
</div>
<div id="other-models" class="section level3" number="16.6.1">
<h3>
<span class="header-section-number">16.6.1</span> Other models<a class="anchor" aria-label="anchor" href="#other-models"><i class="fas fa-link"></i></a>
</h3>
<p>Other models use a larger number of parameters, attempting to model mutations more precisely. For example, the <strong>Kimura 2-parameter model</strong> uses the matrix:</p>
<p><span class="math display">\[
Q = \begin{pmatrix}
-\beta - 2 \gamma &amp; \beta &amp; \gamma &amp; \gamma \\
\beta &amp; -\beta - 2 \gamma &amp; \gamma &amp; \gamma \\
\gamma &amp; \gamma &amp; -\beta - 2 \gamma &amp; \beta  \\
\gamma &amp; \gamma &amp; \beta &amp; -\beta - 2 \gamma\\
\end{pmatrix}
\]</span></p>
<p>Which can be treated in the same way as above, leading to a 2-parameter <span class="math inline">\(M(t)\)</span>.</p>
</div>
<div id="maximum-likelihood" class="section level3" number="16.6.2">
<h3>
<span class="header-section-number">16.6.2</span> Maximum likelihood<a class="anchor" aria-label="anchor" href="#maximum-likelihood"><i class="fas fa-link"></i></a>
</h3>
<p>Armed with the definitions above, we now want to fit a length of an edge stemming from the root. We have sequences <span class="math inline">\(S0\)</span> and <span class="math inline">\(S1\)</span>, and we build the matrix <span class="math inline">\(N\)</span> whose elements <span class="math inline">\(n_{ij}\)</span> counts the number of bases that were of type <span class="math inline">\(i\)</span> in the ancestral state, and <span class="math inline">\(j\)</span> in the descendant.</p>
<p>For example:</p>
<p><span class="math display">\[
S0: ATTACGGTT
\]</span>
<span class="math display">\[
S1: AAGGTCGTT
\]</span></p>
<p>Then the matrix <span class="math inline">\(N\)</span> (the order is always <code>AGCT</code>) becomes:</p>
<p><span class="math display">\[
N = \begin{pmatrix}
1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 2
\end{pmatrix}
\]</span></p>
<p>We want to know what is the maximum likelihood estimate for the time between <span class="math inline">\(S0\)</span> and <span class="math inline">\(S1\)</span> given a model.</p>
<p>For example, if we choose the Jukes-Cantor model, we have that we assume <span class="math inline">\(p_0 = (1/4, 1/4, 1/4, 1/4)\)</span>, and the probabilities of observing a given transition would be:</p>
<p><span class="math display">\[
P(t) = \text{diag}(p_0) M(t) = \begin{pmatrix}
(1- a(t)) / 4  &amp; a(t) / 12 &amp; a(t) / 12 &amp; a(t) / 12 \\
a(t) / 12 &amp; (1 -a(t)) / 4 &amp;  a(t) / 12 &amp; a(t) / 12 \\
a(t) / 12 &amp; a(t) / 12 &amp;  (1 -a(t))/4 &amp;  a(t) / 12 \\
a(t) / 12 &amp; a(t) / 12 &amp;   a(t) / 12 &amp; (1-a(t)) / 4
\end{pmatrix}
\]</span></p>
<p>The likelihood of a given edge length, <span class="math inline">\(t\)</span> would be:</p>
<p><span class="math display">\[
L(t \vert N ) = \prod_{i,j} p_{ij}^{n_{ij}}
\]</span></p>
<p>Taking the log-likelihood:</p>
<p><span class="math display">\[
\log L(t \vert N ) = \sum_{i,j} {n_{ij} \log p_{ij}} = \log(a / 12) \sum_{j\neq i} n_{ij} + \log((1-a) / 4) \sum_i n_{ii}
\]</span></p>
<p>Taking the derivative with respect to <span class="math inline">\(t\)</span>, setting it to zero, and massaging the equation we obtain:</p>
<p><span class="math display">\[
a(\hat{t}) = \frac{\sum_{j\neq i} n_{ij}}{\sum_{j, i} n_{ij}}
\]</span></p>
<p>For example, for the matrix above <span class="math inline">\(a(\hat{t}) = 5/9\)</span>. Because <span class="math inline">\(a(t) = 3/4 (1 - e^{(-t 4/3)})\)</span>, we get <span class="math inline">\(\hat{t} \approx 1.0124\)</span>, setting the maximum likelihood estimate for the length of the branch.</p>
<p>Using this method, we can find the maximum likelihood estimate for all the branches of a tree. We can then propose a tree, and then compute the product of all likelihoods. Given that there are many possible trees, we need a smart way to explore the space.
The algorithm by Felsenstein (1981, <em>Evolutionary trees from DNA sequences: a maximum likelihood approach</em>) was the first to allow an efficient search of the space of trees, and the first to propose the method above to find optimal branch lengths.</p>
<p>Compute using a Jukes-Cantor model:</p>
<div class="sourceCode" id="cb912"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># compute likelihoods</span></span>
<span><span class="va">test_NJ</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/pml.html">pml</a></span><span class="op">(</span><span class="va">treeUPGMA</span>, data<span class="op">=</span><span class="va">primates</span>, model <span class="op">=</span> <span class="st">"JC"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">test_NJ</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 
## model: JC 
## 
## loglikelihood: -3079.976 
## 
## unconstrained loglikelihood: -1230.335 
## 
## Rate matrix:
##   a c g t
## a 0 1 1 1
## c 1 0 1 1
## g 1 1 0 1
## t 1 1 1 0
## 
## Base frequencies:  
## 0.25 0.25 0.25 0.25</code></pre>
<p>Try optimizing by allowing changes in topology:</p>
<div class="sourceCode" id="cb914"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitJC</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/pml.html">optim.pml</a></span><span class="op">(</span><span class="va">test_NJ</span>, data<span class="op">=</span><span class="va">primates</span>,</span>
<span>                    rearrangement <span class="op">=</span> <span class="st">"NNI"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## optimize edge weights:  -3079.976 --&gt; -3070.764 
## optimize edge weights:  -3070.764 --&gt; -3070.764 
##  optimize topology:  -3070.764 --&gt; -3068.417 
##  NNI moves:  1 
##  optimize topology:  -3068.417 --&gt; -3068.295 
##  NNI moves:  1 
##  optimize topology:  -3068.295 --&gt; -3068.295 
##  NNI moves:  0 
## NNI moves:  2 
## optimize edge weights:  -3068.295 --&gt; -3068.295 
##  optimize topology:  -3068.295 --&gt; -3068.295 
##  NNI moves:  0 
## NNI moves:  0</code></pre>
<div class="sourceCode" id="cb916"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">fitJC</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 
## model: JC 
## 
## loglikelihood: -3068.295 
## 
## unconstrained loglikelihood: -1230.335 
## 
## Rate matrix:
##   a c g t
## a 0 1 1 1
## c 1 0 1 1
## g 1 1 0 1
## t 1 1 1 0
## 
## Base frequencies:  
## 0.25 0.25 0.25 0.25</code></pre>
<div class="sourceCode" id="cb918"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">fitJC</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="BIOS_26318_2020_files/figure-html/unnamed-chunk-380-1.png" width="672"></div>
</div>
<div id="bayesian-methods" class="section level3" number="16.6.3">
<h3>
<span class="header-section-number">16.6.3</span> Bayesian methods<a class="anchor" aria-label="anchor" href="#bayesian-methods"><i class="fas fa-link"></i></a>
</h3>
<p>These methods can be extended to include priors. We can use a flat prior for the ancestral sequence, for the base substitution model, and over the space of possible trees and, via MCMC, construct the posterior distribution for all the parameters. The hope is to find strong support (i.e., posterior probability close to one) for a single tree; alternatively, many trees with high posterior can be summarized in a consensus tree.</p>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="machine-learning-methods-for-classification.html"><span class="header-section-number">15</span> Machine learning methods for classification</a></div>
<div class="next"><a href="time-series-modeling-and-forecasting.html"><span class="header-section-number">17</span> Time series: modeling and forecasting</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#building-phylogeneric-trees"><span class="header-section-number">16</span> Building phylogeneric trees</a></li>
<li><a class="nav-link" href="#introduction-2"><span class="header-section-number">16.1</span> Introduction</a></li>
<li><a class="nav-link" href="#input-1"><span class="header-section-number">16.2</span> Input</a></li>
<li><a class="nav-link" href="#representing-trees"><span class="header-section-number">16.3</span> Representing trees</a></li>
<li>
<a class="nav-link" href="#building-trees-from-sequence-data"><span class="header-section-number">16.4</span> Building trees from sequence data</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#maximum-parsimony"><span class="header-section-number">16.4.1</span> Maximum Parsimony</a></li>
<li><a class="nav-link" href="#example-primates"><span class="header-section-number">16.4.2</span> Example: primates</a></li>
<li><a class="nav-link" href="#parsimonygate"><span class="header-section-number">16.4.3</span> #ParsimonyGate</a></li>
</ul>
</li>
<li><a class="nav-link" href="#distance-methods"><span class="header-section-number">16.5</span> Distance Methods</a></li>
<li>
<a class="nav-link" href="#likelihood-based-methods"><span class="header-section-number">16.6</span> Likelihood based methods</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#other-models"><span class="header-section-number">16.6.1</span> Other models</a></li>
<li><a class="nav-link" href="#maximum-likelihood"><span class="header-section-number">16.6.2</span> Maximum likelihood</a></li>
<li><a class="nav-link" href="#bayesian-methods"><span class="header-section-number">16.6.3</span> Bayesian methods</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Fundamentals of Biological Data Analysis</strong>" was written by Dmitry Kondrashov and Stefano Allesina. It was last built on 2022-11-12.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
