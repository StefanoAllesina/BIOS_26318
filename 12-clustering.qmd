# Clustering

**Goals**

-   Learn about partitional clustering
-   Learn about hierarchical clustering
-   Use clustering validation methods
-   Apply different methods to larger data sets

```{webr-r}
library(ggfortify) 
# library(factoextra) 
library(NbClust)
#library(fpc)
library(hopkins)
library(palmerpenguins)
```

The goal of clustering is to classify data points into groups (clusters) by without giving the algorithm any knowledge of the correct classification. This type of approach is called *unsupervised learning* and it is appropriate when the "truth" for your data classification is unavailable or difficult to obtain.

If the truth is unknown, we need a way of deciding which data points belong together. One common set of approaches relies on a measure of closeness, or distance between points. Of those, the classic K-means approach is the most straightforward.

## K-means algorithm

-   divide data into K clusters
-   calculate centroids for each
-   go through each data point until nothing changes
    -   calculate distance to each centroid
    -   assign to nearest centroid
    -   recalculate centroids for the two affected clusters

Let us apply the k-means algorithm to our well-studied penguin data set. In the script below, we remove the NAs, and select out the categorical variables, as they are not directly useful for the distance-based algorithm, leaving the four numeric variables to define similarity between individuals. The question is, will they cluster penguins according to species?t

```{webr-r}
#set.seed(20)
glimpse(penguins)
pen_data <- penguins |> drop_na() 
#pen_train <- pen_data  |> dplyr::select(-species,-island, -sex, -year) # remove species (the true labels)
pen_train <- pen_data  |> dplyr::select(-species,-island, -sex) # remove species (the true labels)
pen_km <- kmeans(pen_train, 3) #k-means with 3 clusters
pen_km
table(pen_km$cluster, pen_data$species)

fviz_cluster(list(data = pen_train, cluster = pen_km$cluster),
ellipse.type = "norm", geom = "point", stand = FALSE, palette = "jco", ggtheme = theme_classic())
```

The plot is produced by performing PCA to reduce the number of variables from 4 to 2, helping present the data points in the way that optimizes their visual separation. Notice that the clusters are not well separated, and when compared with the actual classification given by `species`, they do not do well.

However, the four measurements have very different variances, so we try scaling them to make them all have equal variance of one:

```{webr-r}
pen_data <- penguins |> drop_na()
#pen_scaled <- scale(pen_data |> dplyr::select(-species, -island, -sex, -year) )
pen_scaled <- scale(pen_data |> dplyr::select(-species, -island, -sex) )
pen_km <- kmeans(pen_scaled, 3)
pen_km
table(pen_km$cluster, pen_data$species)

fviz_cluster(list(data = pen_scaled, cluster = pen_km$cluster),
ellipse.type = "norm", geom = "point", stand = FALSE, palette = "jco", ggtheme = theme_classic())
```

Now we get much better separation, as well as much better prediction quality. However, if you run the above code several times, you will see different results, because k-means starts with a random selection of centroids. In cases like this, where there is not very obvious clusters, it may converge to different classifications. Here, for some trials we see very good prediction quality for all three species, but other times two of the species are commingled.

### Assumptions of K-means algorithm

-   There is a meaningful distance measure
-   Clusters are roughly spherical
-   Clusters are of similar size

```{webr-r}
# Generate random data which will be first cluster
clust1 <- data_frame(x = rnorm(200), y = rnorm(200))
# Generate the second cluster which will ‘surround’ the first cluster
clust2 <- data_frame(r = rnorm(200, 15, .5), 
                     theta = runif(200, 0, 2 * pi),
                 x = r * cos(theta), y = r * sin(theta)) |>
  dplyr::select(x, y)
#Combine the data
dataset_cir <- rbind(clust1, clust2)
#see the plot
dataset_cir |> ggplot() + aes(x = x, y = y) + geom_point()
```

```{webr-r}
#Fit the k-means model
k_clust_spher1 <- kmeans(dataset_cir, centers=2)
#Plot the data and clusters
fviz_cluster(list(data = dataset_cir, 
                  cluster = k_clust_spher1$cluster),
             ellipse.type = "norm", 
             geom = "point", stand = FALSE, 
             palette = "jco", 
             ggtheme = theme_classic())
```

```{webr-r}
# Make the first cluster with 200 random values
clust1 <- data_frame(x = rnorm(200), 
                     y = rnorm(200))
# Keep 10 values together to make the second cluster
clust2 <- data_frame(x=c(5,5.1,5.2,5.3,5.4),
                     y=c(5,5,5,5,5))
#Combine the data
dataset_uneven <- rbind(clust1,clust2)
dataset_uneven |> ggplot() + aes(x = x, y = y) + geom_point()
```

```{webr-r}
k_clust_spher3 <- kmeans(dataset_uneven, centers=2)
fviz_cluster(list(data = dataset_uneven, 
                  cluster = k_clust_spher3$cluster),
             ellipse.type = "norm", 
             geom = "point", 
             stand = FALSE, 
             palette = "jco", 
             ggtheme = theme_classic())
```

## Hierarchical clustering

Hierarchical clustering is different approach from k-means, although it is also based on a notion of distance. The goal is to create a tree, akin to phylogeny, based on proximity of different points to each other, and then to divide it into groups by *cutting* the tree a certain depth from the root.

### Agglomerative clustering

Start with single data points as "clusters," then iteratively combine the closest pair of clusters. The closeness may be defined in the following ways:

1.  Single Linkage: In single linkage, we define the distance between two clusters as the minimum distance between any single data point in the first cluster and any single data point in the second cluster.

2.  Complete Linkage: In complete linkage, we define the distance between two clusters to be the maximum distance between any single data point in the first cluster and any single data point in the second cluster.

3.  Average Linkage: In average linkage, we define the distance between two clusters to be the average distance between data points in the first cluster and data points in the second cluster.

4.  Centroid Method: In centroid method, the distance between two clusters is the distance between the two mean vectors of the clusters.

5.  Ward's Method: This method does not directly define a measure of distance between two points or clusters. It is an ANOVA based approach. One-way univariate ANOVAs are done for each variable with groups defined by the clusters at that stage of the process. At each stage, two clusters merge that provide the smallest increase in the combined error sum of squares.

```{webr-r}
# Use hcut() which compute hclust and cut the tree
cir_hc <- hcut(dataset_cir, k = 2, hc_method = "single")
# Visualize dendrogram
fviz_dend(cir_hc, show_labels = FALSE, rect = TRUE)
# Visualize cluster
fviz_cluster(cir_hc, ellipse.type = "convex")
```

```{webr-r}
# Use hcut() which compute hclust and cut the tree
uneven_hc <- hcut(dataset_uneven, k = 2, hc_method = "single")
# Visualize dendrogram
fviz_dend(uneven_hc, show_labels = FALSE, rect = TRUE)
# Visualize cluster
fviz_cluster(uneven_hc, ellipse.type = "convex")
```

### Clustering penguin data using hierarchical methods

Try different methods and see which one generates the best results

```{webr-r}
# Hierarchical clustering
# ++++++++++++++++++++++++
# Use hcut() which compute hclust and cut the tree
pen_hc <- hcut(pen_scaled, k = 3, hc_method = "complete")
# Visualize dendrogram
fviz_dend(pen_hc)
# Visualize cluster
fviz_cluster(pen_hc)
table(pen_hc$cluster, pen_data$species)
```

**Exercise** Try using different clustering methods!

## Clustering analysis and validation

### Hopkins statistic

Comparing the mean nearest-neighbor distance between uniformly generated sample points and mean nearest-neighbor distance within the data set. $$
H = \frac{\sum u^d_i}{\sum u^d_i + \sum w^d_i}
$$ This quantifies the "clustering tendency" of the data set.

```{webr-r}
# Check Cluster Tendency--Hopkins Statistic
hopkins(pen_scaled) # by default samples about 10% of the data points
# run a couple times to sample repeatedly
```

If H is substantially above 0.5, reject the null hypothesis that the data are generated by a Poisson point process (no clustering tendency.)

```{webr-r}
# Visual Assessment of Cluster Tendency
fviz_dist(dist(pen_scaled), show_labels = FALSE)+ labs(title = "Scaled penguin data")
```

-   Red is high similarity (low dissimilarity)
-   Blue is low similarity (high dissimilarity)

### Elbow method

```{webr-r}
# Elbow method
fviz_nbclust(pen_scaled, kmeans, method = "wss") + geom_vline(xintercept = 2, linetype = 2)+
labs(subtitle = "Elbow method for K-means of the scaled penguin data")
```

### Silhouette Plot

Measures how similar an object $i$ is to the other objects in its same cluster versus the objects outside of its cluster; $S_i$ values range from -1 to 1. Close to 1 means very similar to objects in its own group and dissimilar to others

```{webr-r}
# Silhouette method
fviz_nbclust(pen_scaled, kmeans, method = "silhouette")+ labs(subtitle = "Silhouette method for k-means")
```

### Lazy way: use all the methods!

```{webr-r}
nb <- NbClust(pen_scaled, distance = "euclidean", min.nc = 2,
        max.nc = 10, method = "kmeans")
fviz_nbclust(nb)
```

### Validation using bootstrapping

One common approach to validating clustering is to use the approach called bootstrapping which involves repeatedly sampling from the data set, running the clustering algorithm and comparing the results. One algorithm uses the Jaccard coefficient to quantify similarity between sets, which is defined as the number of points in the intersection of the two sets (those which are in both sets), divided by the number of points in the union of the two sets (the point that are in either one or the other set):

$$
J = \frac{ \vert A \cap B \vert }{\vert A \cup B \vert}
$$ The vertical lines indicate the number of points (cardinality) in the set.

```{webr-r}
k <- 3
cboot.hclust <- clusterboot(pen_scaled, clustermethod=kmeansCBI, k= k)
print(cboot.hclust)

#cboot.hclust <- clusterboot(bcdata, clustermethod=hclustCBI,
       #                    method="single", k=2)
```

## Application to breast cancer data

The following measurements are based on biopsy data on patients with suspected breast cancer (see \[5\]). It contains several measurements of cell characteristics, as well as the classification of each biopsy into malignant or benign (2 or 4). Let us see if using clustering

```{webr-r}
# Import Breast Cancer Data Set
fulldata <- read_csv("https://raw.githubusercontent.com/StefanoAllesina/BIOS_26318/refs/heads/master/data/Wisconsin_Breast_Cancers.csv")
bcdata <- fulldata |> drop_na() |> dplyr::select(-Sample, -Class)
glimpse(fulldata)
```

```{webr-r}
# Visually Inspect Data (PCA)
fviz_pca_ind(prcomp(bcdata), title = "PCA - Breast Cancer data", geom = "point", ggtheme = theme_classic())
```

```{webr-r}
bc_km <- kmeans(scale(bcdata), 2)
bc_km
table(bc_km$cluster, fulldata$Class)
#irisCluster$cluster <- as.factor(irisCluster$cluster)
#ggplot(iris, aes(Petal.Length, Petal.Width, color = iris$cluster)) + geom_point()

fviz_cluster(list(data = bcdata, cluster = bc_km$cluster),
ellipse.type = "norm", geom = "point", stand = FALSE, palette = "jco", ggtheme = theme_classic())
```

```{webr-r}
# Use hcut() which compute hclust and cut the tree
bc_hc <- hcut(scale(bcdata), k = 2, hc_method = "ward")
# Visualize dendrogram
fviz_dend(bc_hc, show_labels = FALSE, rect = TRUE)
# Visualize cluster
fviz_cluster(bc_hc, ellipse.type = "convex")
table(bc_hc$cluster, fulldata$Class)
```

## References:

1.  https://www.r-bloggers.com/exploring-assumptions-of-k-means-clustering-using-r/
2.  https://onlinecourses.science.psu.edu/stat505/node/143/
3.  https://github.com/hhundiwala/hierarchical-clustering
4.  https://www.r-bloggers.com/bootstrap-evaluation-of-clusters/
5.  https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)
